## 概要

本ツールは、Go言語のプロジェクトにおいて以下の2つの機能を提供します。

1. **list-refs**  
   指定されたシンボルの参照箇所を表示します。  

2. **rename**  
   指定されたシンボルを、新しい名前に一括置換します。  

**ポイント**  
- ユーザーは「**1つのGoファイル**」と「操作対象のシンボル名」を指定します。  
- ツールは該当ファイルが属するパッケージを特定するために、まずはディレクトリを参照し、その親ディレクトリを遡って `go.mod` を探します。  
  - `go.mod` が見つかったディレクトリ（＝モジュールルート）配下の**すべてのGoファイル**を解析し、シンボル参照やリネームを行います。  
- 差分表示・バックアップ・安全性確保は行わず、Gitなどのバージョン管理下で使用することを想定しています。

---

## インストール

```
go install github.com/example/refactoring-tool@latest
```

※ 上記は例です。実際のインストール方法はリポジトリURLやバージョンに合わせてご調整ください。

---

## 基本的な使い方

### 1. list-refs

```
tool list-refs <file.go> <symbolName>
```

- 指定されたGoファイル（例: `pkg/foo.go`）が属するモジュールを特定し、そのモジュール内に定義されたシンボル `<symbolName>` がどこで参照されているかを列挙します。  
- シンボル名は単純な関数名や変数名だけでなく、**型名.メソッド名**のような形（例: `MyStruct.DoSomething`）も指定可能です。  

#### 使用例

```
# pkg/foo.go 内に定義されているシンボル Foo の参照箇所をすべて表示
$ tool list-refs pkg/foo.go Foo

# MyStruct 型に定義されているメソッド DoSomething を検索
$ tool list-refs pkg/foo.go MyStruct.DoSomething
```

#### 出力形式

標準出力に参照箇所をテキストとして出力します。例:

```
pkg/foo.go:15:2
pkg/foo.go:48:5
pkg/bar.go:30:10
cmd/main.go:12:3
...
```

- 1行1参照で、`<ファイルパス>:<行番号>:<カラム番号>` の形式です。

#### 主なエラーケース

1. **`go.mod` が見つからない**  
   - 指定ファイルの親ディレクトリを上に辿っても `go.mod` が無い → 「モジュールを特定できません」とエラー。  
2. **シンボルが複数定義 or 見つからない**  
   - 一意に特定できない場合はエラー。  
3. **AST解析エラー**  
   - ソースコードに構文エラーがあり解析に失敗した場合など。  

---

### 2. rename

```
tool rename <file.go> <oldSymbolName> <newSymbolName>
```

- 指定ファイルの属するモジュール全体を解析し、パッケージ内で一意に決まるシンボル `<oldSymbolName>` を `<newSymbolName>` に変更します。  
- 他のファイルにも参照があれば同時に書き換えます（ただし同モジュール内に限る）。  
- 差分の表示やバックアップは行いません。Gitなどでバージョン管理を行っている状態で実行してください。  

#### 使用例

```
# pkg/foo.go 内で定義されている関数 OldFunc を、NewFunc にリネーム
$ tool rename pkg/foo.go OldFunc NewFunc

# MyStruct.DoSomething を DoStuff にリネーム
$ tool rename pkg/foo.go MyStruct.DoSomething DoStuff
```

#### 動作フロー

1. **ファイルからモジュールルートを特定**  
   - `<file.go>` の親ディレクトリを遡って `go.mod` を探し、見つかったディレクトリをモジュールルートとする。  
2. **モジュール配下のAST解析**  
   - モジュール内のすべての `.go` ファイルを解析し、シンボルの定義・参照を収集。  
3. **リネーム対象の特定**  
   - `<oldSymbolName>` に一致するシンボルを検索。  
   - 同じパッケージ内に複数定義があればエラー、一意に決まらない場合もエラー。  
4. **書き換え（リネーム）**  
   - `<newSymbolName>` が既存シンボル名と衝突しないかチェック。衝突すればエラー。  
   - 問題がなければ、該当シンボルの全参照箇所を `<newSymbolName>` に置換。ファイルを上書き保存。  

#### エラーケース

1. **衝突**  
   - 既に `<newSymbolName>` という名前のシンボルがありコンパイルが破綻する場合 → エラー終了。  
2. **複数定義 or 無定義**  
   - `<oldSymbolName>` が一意に特定できない → エラー。  
3. **ビルド不可**  
   - 大きな構文エラーなどで解析不能 → エラー。  

---

## 処理範囲の決定

1. **単一ファイル指定**  
   - 一つの `.go` ファイルに複数の `package` 宣言を混在させることはGo言語の仕様上できません。  
   - そのため、指定ファイル内のパッケージは一意に決まります。  
2. **同モジュール内への影響**  
   - リネームなどで他のファイルにも参照がある場合はすべて置き換えます。  
   - モジュール外（別の `go.mod`）にあるコードは対象外。  
3. **テストパッケージとの衝突**  
   - 指定ファイルが `package foo` なら、そのファイルはテストパッケージではないため衝突は起きません。  
   - もしファイルが `package foo_test` であれば、それは明確にテストパッケージになるため、一意に決まります。  
   - 同ディレクトリに別パッケージ（`foo_test`）があっても、指定ファイルが `foo.go` なら `package foo` を扱うため、衝突はありません。  

---

## 例: 実行シナリオ

### 1. 参照先を確認する

```bash
$ tree .
.
├── go.mod
├── pkg
│   ├── foo.go   # ここに MyStruct, OldFunc が定義されている
│   ├── bar.go
│   └── foo_test.go
└── cmd
    └── main.go

# MyStruct.DoSomething の参照箇所を一覧表示
$ tool list-refs pkg/foo.go MyStruct.DoSomething
pkg/foo.go:15:2
pkg/bar.go:42:8
cmd/main.go:10:5
```

### 2. リネーム

```bash
# OldFunc -> NewFunc に変更
$ tool rename pkg/foo.go OldFunc NewFunc
Renamed 'OldFunc' -> 'NewFunc' in:
- pkg/foo.go (2 occurrences)
- pkg/bar.go (1 occurrence)
- cmd/main.go (1 occurrence)
```

(実際のツール実装では変更後の行数や詳細が表示される仕様にしてもよい)

---

## 注意事項

1. **差分表示はしない**  
   - 実行後に上書き保存するため、作業前にコミットするなどGitでの管理を推奨。  
2. **大規模プロジェクトでのパフォーマンス**  
   - モジュール全体を解析するため、膨大なファイルを一度に読み込む場合があります。  
   - 並列処理やキャッシュを導入して高速化を図っていますが、数十万行を超える場合はリネーム範囲を必要最小限にする運用が望ましいです。  
3. **外部モジュールへの影響はなし**  
   - リネーム先が外部ライブラリに影響を及ぼすことはありませんし、外部ライブラリのシンボルを変更することもできません。  
4. **衝突や曖昧さはエラーで終了**  
   - 自動で解決しようとはせず、ユーザーに明確に再指定を促します。

---

## 今後の拡張（例）

- **`--dry-run`**: リネーム結果を適用せず、変更予定箇所の一覧だけを出力。  
- **`--diff`**: 実際の差分を表示する機能。  
- **テストパッケージの扱い拡張**: ディレクトリに複数パッケージがある場合にも対応（現状は指定ファイルが1つのパッケージを確定させるため、競合なし）。  
- **ビルドタグ対応**: 特定のビルドタグを有効/無効にして解析したいケースに対応。  
- **インポートパスの変更**: パッケージを移動・改名し、モジュール内のインポート文を自動更新する機能など。

